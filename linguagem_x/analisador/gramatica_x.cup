/**
 * Especificação do analisador sintático para a Linguaguem X
 * java -jar ../utilitarios/java-cup-11a.jar -interface -parser AnalisadorSintatico -symbols iSimbolo gramatica_x.cup
 */
package analisador;

import java.util.*;
import java_cup.runtime.*;
import sintaxe_abstrata.*;

parser code  {:
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error ");

        if (info instanceof java_cup.runtime.Symbol) {
            m.append( "("+info.toString()+")" );
        }
        m.append(" : "+message);
        System.out.println(m);
    }
   
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Fatal Syntax Error");
    }
:};


// Palavras-chave
terminal VAR, CONS;
terminal BOOLEAN, INT, REAL;
terminal FUNCTION;
terminal PROCEDURE;
terminal IF, THEN, ELSE;
terminal WHILE;

terminal LBRACK, RBRACK, LBRACE, RBRACE, LPAREN, RPAREN;
terminal SEMICOLON, COMMA, PIPE;
terminal EQ, EQEQ;
terminal PLUS, MINUS, MULT, DIV, MOD, UMINUS;
terminal LT, GT;
terminal AND, OR, NOT;

// Terminais Literais
terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Double REAL_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String IDENTIFIER;


// Produções
non terminal Programa program;
non terminal List<Dec> dec_list;
non terminal Dec dec;
non terminal DVar dec_var;
non terminal DCons dec_cons;
non terminal VarInic var_inic;
non terminal VarNaoInic var_ninic;
non terminal VarInicExt var_inic_ext;
non terminal VarInicComp var_comp;
non terminal Tipo tipo;
non terminal TipoBase tipo_base;
non terminal TipoArray tipo_array;
non terminal TBase numerico;
non terminal List<Exp> lista_dimensao, lista_expressao, exp_opt,
                       inicializador_array;
non terminal Exp dimensao, literal, expressao, primaria, corpo_func, dec_exp;
non terminal VarExp var_exp;
non terminal Var simples_indexada;
non terminal ChamadaExp chamada;
non terminal Funcao dec_func;
non terminal java.lang.String declarador_var_id;
non terminal Object[] ass_func, ass_proc, inicializador_array_comp, id_compreensao;
non terminal List<Parametro> lista_param_formal_opt, lista_param_formal,
                             lista_param_formal_proc_opt, lista_param_formal_proc;
non terminal Parametro param_formal, param_ref, param_copia;
non terminal BlocoExp bloco_exp, dec_bloco_exp_opt, dec_bloco_exp;
non terminal List<DCons> dec_bloco_cons_opt, dec_bloco_cons;
non terminal Procedimento dec_proc;
non terminal Comando comando, comando_restrito;
non terminal DVarConsCom dec_comandos;
non terminal WHILE while;
non terminal ASSIGN assign;
non terminal CHAMADA chamada_comando;
non terminal BLOCO bloco, bloco_comandos_opt;
non terminal List<DVarConsCom> bloco_comandos;


// Precedência dos operadores
precedence right EQ;
precedence left EQEQ, GT, LT; // Operadores relacionais
precedence left PLUS, MINUS, OR; // Operadores de adição
precedence left MULT, DIV, MOD, AND; // Operadores de multiplicação
precedence nonassoc UMINUS;


start with program;


/******************************************************************************
 * ESTRUTURA DE UM PROGRAMA EM X
 *****************************************************************************/
program ::= dec_list:d {: RESULT = new Programa(d); :} ;

dec_list ::=
        dec:d {: RESULT = new ArrayList<Dec>(Arrays.asList(d)); :}
    |   dec_list:dl dec:d {: dl.add(d); RESULT = dl; :}
    ;

dec ::=
        dec_var:d {: RESULT = new DecVar(d); :}
    |   dec_cons:d {: RESULT = new DecCons(d); :}
    |   dec_func:d {: RESULT = d; :}
    |   dec_proc:d {: RESULT = d; :}
    ;

/******************************************************************************
 * PRODUÇÕES FUNDAMENTAIS
 *****************************************************************************/
tipo ::=
        tipo_base:t {: RESULT = t; :}
    |   tipo_array:t {: RESULT = t; :}
    ;

tipo_base ::=
        numerico:n {: RESULT = new TipoBase(n); :}
    |   BOOLEAN {: RESULT = new TipoBase(TBase.Bool); :}
    ;

tipo_array ::=
        numerico:t lista_dimensao:d {: RESULT = new TipoArray(t, d); :}
    |   BOOLEAN lista_dimensao:d {: RESULT = new TipoArray(TBase.Bool, d); :}
    ;

lista_dimensao ::=
        dimensao:d {: RESULT = new ArrayList<Exp>(Arrays.asList(d)); :}
    |   lista_dimensao:ld dimensao:d {: ld.add(d); RESULT = ld; :}
    ;

dimensao ::= LBRACK expressao:e RBRACK {: RESULT = e; :};

numerico ::=
        INT {: RESULT = TBase.Int; :}
    |   REAL {: RESULT = TBase.Real; :}
    ;

literal ::=
        INTEGER_LITERAL:l {: RESULT = new LiteralInt(l); :}
    |   REAL_LITERAL:l {: RESULT = new LiteralReal(l); :}
    |   BOOLEAN_LITERAL:l {: RESULT = new LiteralBool(l); :}
    ;

expressao ::=
        primaria:p {: RESULT = p; :}
    |   expressao:e1 PLUS expressao:e2
        {: RESULT = new BinExp(BinOp.Som, e1, e2); :}
    |   expressao:e1 MINUS expressao:e2
        {: RESULT = new BinExp(BinOp.Sub, e1, e2); :}
    |   expressao:e1 MULT expressao:e2
        {: RESULT = new BinExp(BinOp.Mul, e1, e2); :}
    |   expressao:e1 DIV expressao:e2
        {: RESULT = new BinExp(BinOp.Div, e1, e2); :}
    |   expressao:e1 MOD expressao:e2
        {: RESULT = new BinExp(BinOp.Mod, e1, e2); :}
    |   expressao:e1 GT expressao:e2
        {: RESULT = new BinExp(BinOp.Maior, e1, e2); :}
    |   expressao:e1 LT expressao:e2
        {: RESULT = new BinExp(BinOp.Menor, e1, e2); :}
    |   expressao:e1 EQEQ expressao:e2
        {: RESULT = new BinExp(BinOp.Igual, e1, e2); :}
    |   expressao:e1 AND expressao:e2
        {: RESULT = new BinExp(BinOp.E, e1, e2); :}
    |   expressao:e1 OR expressao:e2
        {: RESULT = new BinExp(BinOp.Ou, e1, e2); :}
    |   MINUS expressao:e1 {: RESULT = new Menos(e1); :} %prec UMINUS
    |   NOT expressao:e1 {: RESULT = new Nao(e1); :}
    ;

primaria ::=
        LPAREN expressao:e RPAREN {: RESULT = e; :}
    |   literal:l {: RESULT = l; :}
    |   var_exp:v {: RESULT = v; :}
    |   chamada:c {: RESULT = c; :}
    ;

chamada ::=
        IDENTIFIER:i LPAREN exp_opt:e RPAREN
        {: RESULT = new ChamadaExp(i, e); :}
    ;

var_exp ::= simples_indexada:v {: RESULT = new VarExp(v); :} ;

simples_indexada ::=
        IDENTIFIER:i {: RESULT = new Simples(i); :}
    |   simples_indexada:v dimensao:d {: RESULT = new Indexada(v, d); :}
    ;

exp_opt ::=
        {: RESULT = new ArrayList<Exp>(); :}
    |   lista_expressao:l {: RESULT = l; :}
    ;

lista_expressao ::=
        expressao:e {: RESULT = new ArrayList<Exp>(Arrays.asList(e)); :}
    |   lista_expressao:le COMMA expressao:e {: le.add(e); RESULT = le; :}
    ;

comando ::=
        bloco:b {: RESULT = b; :}
    |   IF LPAREN expressao:e RPAREN THEN comando:c
        {: RESULT = new IF(e, c, null); :}
    |   IF LPAREN expressao:e RPAREN THEN comando_restrito:c1 ELSE comando:c2
        {: RESULT = new IF(e, c1, c2); :}
    |   while:w {: RESULT = w; :}
    |   assign:a {: RESULT = a; :}
    |   chamada_comando:c {: RESULT = c; :}
    ;

// Proibe IF's sem ELSE dentro de um THEN em um IF-THEN-ELSE
comando_restrito ::=
        bloco:b {: RESULT = b; :}
    |   IF LPAREN expressao:e RPAREN THEN comando_restrito:c1 ELSE comando_restrito:c2
        {: RESULT = new IF(e, c1, c2); :}
    |   WHILE LPAREN expressao:e RPAREN comando_restrito:c
        {: RESULT = new WHILE(e, c); :}
    |   assign:a {: RESULT = a; :}
    |   chamada_comando:c {: RESULT = c; :}
    ;

while ::=
        WHILE LPAREN expressao:e RPAREN comando:c
        {: RESULT = new WHILE(e, c); :}
    ;

assign ::=
        simples_indexada:i EQ expressao:e SEMICOLON
        {: RESULT = new ASSIGN(i, e); :}
    ;

chamada_comando ::=
        IDENTIFIER:i LPAREN exp_opt:e RPAREN
        {: RESULT = new CHAMADA(i, e); :}
    ;

bloco ::= LBRACE bloco_comandos_opt:b RBRACE {: RESULT = b; :};

bloco_comandos_opt ::=
        {: RESULT = new BLOCO(null); :}
    |   bloco_comandos:b {: RESULT = new BLOCO(b); :}
    ;

bloco_comandos ::=
        dec_comandos:c {: RESULT = new ArrayList<DVarConsCom>(Arrays.asList(c)); :}
    |   bloco_comandos:lc dec_comandos:c {: lc.add(c); RESULT = lc; :}  
    ;

dec_comandos ::=
        comando:c {: RESULT = new Com(c); :}
    |   dec_var:v {: RESULT = new DV(v); :}
    |   dec_cons:c {: RESULT = new DC(c); :}
    ;

/******************************************************************************
 * DECLARAÇÃO DE VARIÁVEIS E CONSTANTES
 *****************************************************************************/
dec_var ::=
        var_ninic:v {: RESULT = v; :}
    |   var_inic:v {: RESULT = v; :}
    |   var_inic_ext:v {: RESULT = v; :}
    |   var_comp:v {: RESULT = v; :}
    ;

var_ninic ::=
        VAR tipo:t declarador_var_id:id SEMICOLON
        {: RESULT = new VarNaoInic(t, id); :}
    ;

var_inic ::=
        VAR tipo:t declarador_var_id:id EQ expressao:e SEMICOLON
        {: RESULT = new VarInic(t, id, e); :}
    ;

var_inic_ext ::=
        VAR tipo:t declarador_var_id:id EQ inicializador_array:le SEMICOLON
        {: RESULT = new VarInicExt(t, id, le); :}
    ;

var_comp ::=
        VAR tipo:t declarador_var_id:id EQ inicializador_array_comp:o SEMICOLON
        {: RESULT = new VarInicComp(t, id, (List<String>) o[0], (Exp) o[1]); :}
    ;

dec_cons ::=
        CONS tipo:t declarador_var_id:id EQ expressao:e SEMICOLON
        {: RESULT = new Cons(t, id, e); :}
    |   CONS tipo:t declarador_var_id:id EQ inicializador_array:le SEMICOLON
        {: RESULT = new ConsExt(t, id, le); :}
    ;

declarador_var_id ::= IDENTIFIER:i {: RESULT = i; :} ;

inicializador_array ::= LBRACE lista_expressao:l RBRACE {: RESULT = l; :} ;

inicializador_array_comp ::=
        id_compreensao:lo {: RESULT = lo; :}
    |   inicializador_array_comp id_compreensao
    ;

id_compreensao ::=
        LBRACE declarador_var_id:id PIPE expressao:e RBRACE
        {:
            Object[] o = new Object[2];
            o[0] = new ArrayList<String>(Arrays.asList(id));
            o[1] = e;
            RESULT = o;
        :}
    |   LBRACE declarador_var_id:id PIPE id_compreensao:lo RBRACE
        {: ((List<String>) lo[0]).add(id); RESULT = lo; :}
    ;
    
/******************************************************************************
 * DECLARAÇÃO DE FUNÇÕES
 *****************************************************************************/
dec_func ::=
        ass_func:a corpo_func:c
        {: RESULT = new Funcao((Tipo) a[0], (String) a[1], (List<Parametro>) a[2], c); :}
    ;

ass_func ::=
        FUNCTION tipo:t IDENTIFIER:i LPAREN lista_param_formal_opt:l RPAREN
        {: Object[] o = new Object[3]; o[0] = t; o[1] = i; o[2] = l; RESULT = o; :}
    ;

lista_param_formal_opt ::=
        {: RESULT = new ArrayList<Parametro>(); :}
    |   lista_param_formal:l {: RESULT = l; :}
    ;

lista_param_formal ::=
        param_formal:p
        {: RESULT = new ArrayList<Parametro>(Arrays.asList(p)); :}
    |   lista_param_formal:lp COMMA param_formal:p
        {: lp.add(p); RESULT = lp; :} 
    ;

param_formal ::=
        param_ref:p {: RESULT = p; :}
    |   param_copia:p {: RESULT = p; :}
    ;

param_ref ::=
        tipo_base:t declarador_var_id:id
        {: RESULT = new ParBaseRef(t.tipo, id); :}
    |   tipo_array:t declarador_var_id:id
        {: RESULT = new ParArrayRef(t.base, t.exp.size(), id); :}
    ;

param_copia ::=
        VAR tipo_base:t declarador_var_id:id
        {: RESULT = new ParBaseCopia(t.tipo, id); :}
    |   VAR tipo_array:t declarador_var_id:id
        {: RESULT = new ParArrayCopia(t.base, t.exp.size(), id); :}
    ;

corpo_func ::=
        expressao:e SEMICOLON {: RESULT = e; :}
    |   bloco_exp:b {: RESULT = b; :}
    ;

bloco_exp ::= LBRACE dec_bloco_exp_opt:d RBRACE {: RESULT = d; :} ;

dec_bloco_exp_opt ::=
        {: RESULT = new BlocoExp(null, null); :}
    |   dec_bloco_exp:d {: RESULT = d; :}
    ;

dec_bloco_exp ::=
        dec_bloco_cons_opt:ld dec_exp:e {: RESULT = new BlocoExp(ld, e); :}
    ;

dec_bloco_cons_opt ::=
        {: RESULT = new ArrayList<DCons>(); :}
    |   dec_bloco_cons:ld {: RESULT = ld; :}
    ;

dec_bloco_cons ::=
        dec_cons:d {: RESULT = new ArrayList<DCons>(Arrays.asList(d)); :}
    |   dec_bloco_cons:ld dec_cons:d {: ld.add(d); RESULT = ld; :}
    ;

dec_exp ::= expressao:e SEMICOLON {: RESULT = e; :} ;

/******************************************************************************
 * DECLARAÇÃO DE PROCEDIMENTOS
 *****************************************************************************/
dec_proc ::=
    ass_proc:a comando:c
    {: RESULT = new Procedimento((String) a[0], (List<Parametro>) a[1], c); :}
;

ass_proc ::=
        PROCEDURE IDENTIFIER:i LPAREN lista_param_formal_proc_opt:l RPAREN
        {: Object[] o = new Object[2]; o[0] = i; o[1] = l; RESULT = o; :}
    ;

lista_param_formal_proc_opt ::=
        {: RESULT = new ArrayList<Parametro>(); :}
    |   lista_param_formal_proc:l {: RESULT = l; :}
    ;

lista_param_formal_proc ::=
        param_ref:p {: RESULT = new ArrayList<Parametro>(Arrays.asList(p)); :}
    |   lista_param_formal_proc:lp COMMA param_ref:p
        {: lp.add(p); RESULT = lp; :} 
    ;